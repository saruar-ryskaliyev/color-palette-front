{"ast":null,"code":"/* eslint-disable eslint-comments/no-unlimited-disable */\n\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n  onGestureActivated(event) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true\n    });\n  }\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    } // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name); // @ts-ignore FIXME(TS)\n\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection()\n    };\n  }\n  getTargetDirections(direction) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    } // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n\n    return directions;\n  }\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const {\n      direction\n    } = this.getConfig();\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n  isGestureEnabledForEvent({\n    numberOfPointers\n  }, _recognizer, {\n    maxPointers: pointerLength\n  }) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n    return {\n      success: validPointerCount\n    };\n  }\n  updateGestureConfig({\n    numberOfPointers = 1,\n    direction,\n    ...props\n  }) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props\n    });\n  }\n}\nexport default FlingGestureHandler;","map":{"version":3,"names":["Hammer","Direction","GesturePropError","DraggingGestureHandler","isnan","FlingGestureHandler","name","NativeGestureClass","Swipe","onGestureActivated","event","sendEvent","eventType","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","onRawEvent","ev","setTimeout","cancelEvent","gesture","hammer","get","options","enable","onStart","getHammerConfig","pointers","config","numberOfPointers","direction","getDirection","getTargetDirections","directions","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","isGestureEnabledForEvent","_recognizer","maxPointers","pointerLength","validPointerCount","failed","success","updateGestureConfig","props"],"sources":["/Users/saruar/Desktop/color palette/color-palette/node_modules/react-native-gesture-handler/lib/module/web_hammer/FlingGestureHandler.ts"],"sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nimport { HammerInputExt } from './GestureHandler';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event: HammerInputExt) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore FIXME(TS)\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction: number) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    { numberOfPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}